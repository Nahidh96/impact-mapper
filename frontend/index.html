<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Meteor Madness • Mission Control</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header class="top-bar">
    <div class="brand">
      <span class="brand-mark">☄️</span>
      <span class="brand-text">Meteor Madness</span>
    </div>
    <nav class="nav-links">
      <a href="#mission">Mission</a>
      <a href="#control">Control Deck</a>
      <a href="#visualizations">Visuals</a>
      <a href="#mission-control">Defend Earth</a>
      <a href="#knowledge">Intel Hub</a>
    </nav>
    <button class="cta" id="cta-brief">Download Briefing</button>
  </header>

  <main class="app-shell">
    <section class="hero" id="mission">
      <div class="hero-copy">
        <p class="tag">NASA Space Apps 2025 • Meteor Madness</p>
        <h1>Coordinate the ultimate planetary defense mission.</h1>
        <p class="subtitle">Stream real-time impact analytics, visualize asteroid trajectories, and deploy deflection strategies before time runs out.</p>
        <div class="hero-actions">
          <button class="primary" id="hero-run">Run Impact Simulation</button>
          <button class="ghost" id="hero-save">Save Scenario Snapshot</button>
        </div>
        <div class="hero-metrics">
          <div class="metric-card">
            <p class="metric-label">Next Close Approach</p>
            <p class="metric-value" id="neo-approach-countdown">—</p>
            <p class="metric-sub" id="neo-approach-date">Awaiting NeoWs data</p>
          </div>
          <div class="metric-card">
            <p class="metric-label">Live Risk Level</p>
            <p class="metric-value" id="severity-label">Scanning...</p>
            <p class="metric-sub" id="severity-tagline">Awaiting data</p>
          </div>
          <div class="metric-card">
            <p class="metric-label">Mission Confidence</p>
            <div class="confidence-bar"><span id="confidence-meter"></span></div>
            <p class="metric-sub" id="confidence-copy">Configure parameters to begin.</p>
          </div>
        </div>
      </div>
      <aside class="hero-side">
        <div class="briefing-card">
          <h3>NEO Intelligence Feed</h3>
          <form class="neo-query" id="neo-query">
            <label for="neo-id-input">NASA NeoWs ID</label>
            <div class="neo-input-row">
              <input type="text" id="neo-id-input" name="neoId" value="3542519" placeholder="e.g. 3542519" autocomplete="off" />
              <button class="secondary" id="load-neo" type="submit">Fetch NEO</button>
            </div>
            <p class="hint">Try famous objects like 3542519 (Apophis), 433 (Eros), or 101955 (Bennu).</p>
          </form>
          <button class="ghost neo-reset" type="button" id="load-mock-neo">Use Hackathon Mock</button>
          <p class="neo-name" id="neo-name">Loading...</p>
          <ul class="neo-facts" id="neo-facts">
            <li>Diameter: —</li>
            <li>Velocity: —</li>
            <li>Close Approach: —</li>
          </ul>
          <p class="neo-status" id="neo-status">Awaiting NASA feed…</p>
        </div>
        <div class="scorecard">
          <h3>Global Defense Leaderboard</h3>
          <ol id="leaderboard">
            <li><strong>Team Syntaxx</strong> — 98.6% mission readiness</li>
            <li>EarthGuard Alliance — 94.2%</li>
            <li>Lunar Shield Coalition — 91.8%</li>
            <li>Planetary Watch — 88.5%</li>
          </ol>
          <p class="scorecard-note">Leaderboard recalculates with each saved scenario.</p>
        </div>
      </aside>
    </section>

    <section class="grid" id="control">
      <article class="card control-panel">
        <header>
          <h2>Impact Parameter Deck</h2>
          <p>Drag the sliders or punch in numbers to craft your scenario.</p>
        </header>
        <div class="input-grid">
          <div class="input-block">
            <label for="diameter">Diameter <span class="unit">meters</span></label>
            <input type="range" id="diameter" min="10" max="2000" step="5" value="150" aria-describedby="diameter-tip" />
            <div class="input-readout"><span id="diameter-val">150</span> m</div>
            <p class="hint" id="diameter-tip">Typical NEOs: 10–1000 m. Try increasing to simulate a Chicxulub-scale impact.</p>
          </div>
          <div class="input-block">
            <label for="velocity">Velocity <span class="unit">km/s</span></label>
            <input type="range" id="velocity" min="11" max="75" step="0.1" value="22.5" aria-describedby="velocity-tip" />
            <div class="input-readout"><span id="velocity-val">22.5</span> km/s</div>
            <p class="hint" id="velocity-tip">Most Earth-approachers arrive between 11–72 km/s. Add Δv to try a deflection.</p>
          </div>
          <div class="input-block">
            <label for="density">Density <span class="unit">kg/m³</span></label>
            <input type="range" id="density" min="500" max="8000" step="50" value="3200" aria-describedby="density-tip" />
            <div class="input-readout"><span id="density-val">3200</span> kg/m³</div>
            <p class="hint" id="density-tip">Choose between porous comets (~500) and iron asteroids (~8000).</p>
          </div>
          <div class="input-block">
            <label for="delta-v">Deflection Δv <span class="unit">km/s</span></label>
            <input type="range" id="delta-v" min="0" max="15" step="0.1" value="0" aria-describedby="delta-tip" />
            <div class="input-readout"><span id="delta-v-val">0</span> km/s</div>
            <p class="hint" id="delta-tip">Inject delta-v to simulate kinetic impactor or gravity tractor missions.</p>
          </div>
        </div>
        <div class="location-picker">
          <p>Impact Location: <span id="impact-location">Tap the map</span></p>
          <button class="secondary" id="reset-location">Reset</button>
        </div>
        <br><br>
        <div class="timeline">
            <p class="section-label">Response Timeline</p>
            <ul id="response-timeline">
              <li>Awaiting simulation...</li>
            </ul>
          </div>
        <br><br>
        <div class="mission-notes-card">
              <div class="notes-header">
                <h3>Mission Control Notes</h3>
                <button class="ghost" id="save-note">Add Mission Note</button>
              </div>
              <ul class="notes" id="mission-notes">
                <li>Assign a landing pad for kinetic impactor follow-up.</li>
                <li>Cross-check regional DEM before rendering crater overlays.</li>
                <li>Queue NASA NeoWs API key in <code>app.py</code> before the live window.</li>
              </ul>
            </div>
      </article>

      <article class="card stats-panel">
        <header>
          <h2>Impact Intelligence</h2>
          <p class="hint">Output from the Flask simulation engine. NASA data slots right in later.</p>
        </header>
        <div class="stat-grid">
          <div class="stat">
            <p class="stat-label">Kinetic Energy</p>
            <p class="stat-value" id="metric-ke">—</p>
            <p class="stat-foot">Joules</p>
          </div>
          <div class="stat">
            <p class="stat-label">TNT Equivalent</p>
            <p class="stat-value" id="metric-tnt">—</p>
            <p class="stat-foot">tons TNT</p>
          </div>
          <div class="stat">
            <p class="stat-label">Crater Diameter</p>
            <p class="stat-value" id="metric-crater">—</p>
            <p class="stat-foot">meters</p>
          </div>
          <div class="stat">
            <p class="stat-label">Seismic Magnitude</p>
            <p class="stat-value" id="metric-seismic">—</p>
            <p class="stat-foot">Mw</p>
          </div>
        </div>
        <div class="insights">
          <div class="insights-left">
            <div class="severity">
              <p class="section-label">Severity Meter</p>
              <div class="severity-meter" id="severity-meter">
                <div class="severity-fill" id="severity-fill"></div>
              </div>
              <p class="hint" id="severity-detail">Adjust parameters to generate insights.</p>
            </div>
          </div>
        </div>
        <canvas id="impact-chart" height="160"></canvas>
      </article>
    </section>

    <section class="visual-section" id="visualizations">
      <header class="section-header">
        <h2>Visualization Hub</h2>
        <p>Monitor orbital dynamics and ground impact footprints in tandem.</p>
      </header>
      <div class="visual-grid">
        <div class="visual-card orbit-card" id="orbit-card">
          <div class="orbit-header">
            <h3>3D Orbit Sandbox</h3>
            <span class="orbit-source" id="orbit-source">Mock Orbit</span>
          </div>
          <div class="orbit-stage-wrapper">
            <div id="orbit-stage"></div>
            <div class="orbit-overlay" id="orbit-overlay">
              <div class="orbit-metric">
                <span>Orbital Period</span>
                <strong id="orbit-period">—</strong>
              </div>
              <div class="orbit-metric">
                <span>Eccentricity</span>
                <strong id="orbit-eccentricity">—</strong>
              </div>
              <div class="orbit-metric">
                <span>Inclination</span>
                <strong id="orbit-inclination">—</strong>
              </div>
              <div class="orbit-metric">
                <span>Δv Plan</span>
                <strong id="orbit-delta">0.0 km/s</strong>
              </div>
            </div>
          </div>
          <p class="hint">Pan and zoom to inspect the trajectory. Δv adjustments reshape the orbit live.</p>
        </div>
        <div class="visual-card" id="map-card">
          <h3>Impact Footprint Map</h3>
          <div id="impact-map"></div>
          <div class="map-legend">
            <span class="legend-dot crater"></span> Crater estimate
            <span class="legend-dot city"></span> Population center
          </div>
        </div>
      </div>
    </section>

    <section class="mission-control" id="mission-control">
      <header class="section-header">
        <h2>Defend Earth Mission Desk</h2>
        <p>Pick a mitigation tactic and compute readiness instantly.</p>
      </header>
      <div class="mission-grid">
        <form class="card mission-form" id="mission-form">
          <h3>Plan a Deflection</h3>
          <label for="strategy">Strategy</label>
          <select id="strategy" required>
            <option value="kinetic">Kinetic Impactor</option>
            <option value="gravity">Gravity Tractor</option>
            <option value="nuclear">Standoff Nuclear</option>
            <option value="laser">Solar Laser Array</option>
          </select>
          <label for="lead-time">Lead Time <span class="unit">days</span></label>
          <input type="number" id="lead-time" min="1" max="720" value="180" />
          <label for="mission-budget">Mission Budget <span class="unit">$B USD</span></label>
          <input type="number" id="mission-budget" min="1" max="500" value="35" />
          <button type="submit" class="primary">Generate Mission Brief</button>
          <p class="hint">Results sync with the parameter deck and severity meter.</p>
        </form>
        <div class="card mission-output">
          <h3>Mission Brief</h3>
          <div id="mission-brief">
            <p>Awaiting mission parameters...</p>
          </div>
          <button class="secondary" id="defend-btn">Activate Defend Earth Mode</button>
          <div class="defend-status" id="defend-result"></div>
        </div>
        <div class="card scenario-vault" id="scenario-vault">
          <h3>Scenario Vault</h3>
          <p class="hint">Saved simulations help iterate strategies fast.</p>
          <ul id="scenario-list">
            <li>No scenarios saved yet.</li>
          </ul>
          <button class="ghost" id="clear-scenarios">Clear Vault</button>
        </div>
      </div>
    </section>

    <section class="intel" id="knowledge">
      <header class="section-header">
        <h2>Intel Hub</h2>
        <p>Explore the physics powering every decision.</p>
      </header>
      <div class="intel-grid">
        <article class="intel-card">
          <h3>Impact Energy</h3>
          <p>The simulator converts asteroid mass and velocity into kinetic energy using <code>E = 1/2 m v^2</code>, then maps it to TNT yield for intuitive comparisons.</p>
        </article>
        <article class="intel-card">
          <h3>Crater Modelling</h3>
          <p>A power-law scaling estimates transient crater size. Swap in high-resolution DEM tiles to engrave realistic footprints.</p>
        </article>
        <article class="intel-card">
          <h3>Seismic Shock</h3>
          <p>Seismic magnitude calculations approximate global shaking via energy release — great for communicating secondary hazards.</p>
        </article>
        <article class="intel-card">
          <h3>Deflection Playbook</h3>
          <p>Compare kinetic impactor, tractor, nuclear, and laser concepts with instant delta-v requirements and lead time guidance.</p>
        </article>
      </div>
    </section>
  </main>

  <footer class="footer">
    <div>
      <strong>Meteor Madness Mission Control</strong>
      <p>Built with cosmic grit by Team Syntaxx for NASA Space Apps 2025.</p>
    </div>
    <div class="footer-links">
      <a href="#mission">Back to top</a>
      <a href="https://www.nasa.gov" target="_blank" rel="noopener">NASA.gov</a>
      <a href="https://api.nasa.gov/" target="_blank" rel="noopener">NeoWs API</a>
    </div>
  </footer>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    const API_BASE = 'http://localhost:5000';
    const DEFAULT_NEO_ID = '3542519';
    const state = {
      impactLat: null,
      impactLng: null,
      craterCircle: null,
      map: null,
      orbit: null,
      asteroidMesh: null,
      orbitGroup: null,
      orbitScene: null,
      orbitCamera: null,
      orbitRenderer: null,
      orbitControls: null,
      orbitControlState: {
        azimuth: Math.PI / 3,
        polar: Math.PI / 3,
        distance: 8
      },
      orbitTrail: null,
      moon: null,
      moonGroup: null,
      moonLight: null,
      moonOrbitLine: null,
      moonOrbitRadius: 6,
      moonOrbitPeriodDays: 27.3,
      baseOrbitParams: {
        semiMajor: 3,
        semiMinor: 1.8,
        inclination: 0,
        ascendingNode: 0,
        periodDays: 365
      },
      orbitParams: {
        semiMajor: 3,
        semiMinor: 1.8,
        inclination: 0,
        ascendingNode: 0,
        periodDays: 365
      },
      chart: null,
      scenarios: [],
      lastReadiness: 98.6,
      currentNeo: null
    };

    const sliderConfig = [
      { id: 'diameter', valueId: 'diameter-val', unit: 'm' },
      { id: 'velocity', valueId: 'velocity-val', unit: 'km/s' },
      { id: 'density', valueId: 'density-val', unit: 'kg/m³' },
      { id: 'delta-v', valueId: 'delta-v-val', unit: 'km/s' }
    ];

    const severityLevels = [
      { threshold: 1e3, label: 'Regional', tagline: 'City-scale blast — activate civil defense.', color: '#3ddab4' },
      { threshold: 1e5, label: 'Continental', tagline: 'Continental impact — coordinate multi-nation response.', color: '#ffb347' },
      { threshold: 1e7, label: 'Global', tagline: 'Global catastrophe — launch planetary-scale mitigation.', color: '#ff6b6b' },
      { threshold: Infinity, label: 'Extinction-Level', tagline: 'Survival-level event. Deploy every asset.', color: '#ff2e63' }
    ];

  document.getElementById('hero-run').addEventListener('click', handleRunImpact);
    document.getElementById('hero-save').addEventListener('click', saveScenario);
    document.getElementById('save-note').addEventListener('click', addMissionNote);
    document.getElementById('cta-brief').addEventListener('click', downloadMissionBrief);
    document.getElementById('reset-location').addEventListener('click', () => {
      state.impactLat = null;
      state.impactLng = null;
      if (state.craterCircle) {
        state.map.removeLayer(state.craterCircle);
        state.craterCircle = null;
      }
      document.getElementById('impact-location').textContent = 'Tap the map';
    });
    document.getElementById('clear-scenarios').addEventListener('click', () => {
      state.scenarios = [];
      renderScenarioVault();
      showToast('Scenario vault cleared.');
    });

    document.getElementById('mission-form').addEventListener('submit', (event) => {
      event.preventDefault();
      const strategy = document.getElementById('strategy').value;
      const lead = Number(document.getElementById('lead-time').value);
      const budget = Number(document.getElementById('mission-budget').value);
      const deltaV = Number(document.getElementById('delta-v').value);
      const diameter = Number(document.getElementById('diameter').value);
      const velocity = Number(document.getElementById('velocity').value);
      const recommendation = buildMissionBrief({ strategy, lead, budget, deltaV, diameter, velocity });
      document.getElementById('mission-brief').innerHTML = recommendation;
      showToast('Mission brief updated — align teams and execute.');
    });

  document.getElementById('defend-btn').addEventListener('click', defendEarth);
  document.getElementById('neo-query').addEventListener('submit', loadSampleNeo);
  document.getElementById('load-mock-neo').addEventListener('click', loadMockNeo);

    sliderConfig.forEach(({ id, valueId }) => {
      const input = document.getElementById(id);
      const valueEl = document.getElementById(valueId);
      const update = () => {
        valueEl.textContent = input.value;
        simulate();
      };
      input.addEventListener('input', update);
      valueEl.textContent = input.value;
    });

    async function loadSampleNeo(event) {
      if (event && typeof event.preventDefault === 'function') {
        event.preventDefault();
      }
      const input = document.getElementById('neo-id-input');
      const button = document.getElementById('load-neo');
      const neoId = (input?.value || '').trim() || DEFAULT_NEO_ID;

      setNeoStatus('Querying NASA NeoWs...');
      if (button) {
        button.disabled = true;
        button.textContent = 'Fetching…';
      }

      try {
        const response = await fetch(`${API_BASE}/neo/${encodeURIComponent(neoId)}`);
        const neo = await response.json();
        renderNeo(neo);
        syncSlidersFromNeo(neo);
        if (response.ok && neo.source === 'nasa') {
          showToast(`Loaded ${neo.name || neoId} from NASA NeoWs.`);
        } else {
          showToast(neo.message || 'NASA data unavailable. Showing mock payload.', true);
        }
      } catch (error) {
        showToast('Unable to reach NASA NeoWs. Falling back to hackathon mock.', true);
        await loadMockNeo(true);
      } finally {
        if (button) {
          button.disabled = false;
          button.textContent = 'Fetch NEO';
        }
      }
    }

    async function loadMockNeo(silent = false) {
      try {
        const response = await fetch('../static/sample_asteroid.json');
        const neo = await response.json();
        neo.source = 'mock';
        neo.message = 'Hackathon mock dataset loaded.';
        neo.requested_id = 'mock';
        neo.resolved_id = neo.id;
        renderNeo(neo);
        syncSlidersFromNeo(neo);
        if (!silent) {
          showToast('Loaded hackathon mock asteroid metadata.');
        }
      } catch (error) {
        const fallback = { name: 'Sample data unavailable', id: 'mock', source: 'mock', message: 'Unable to load static/sample_asteroid.json.' };
        renderNeo(fallback);
        if (!silent) {
          showToast('Sample asteroid file missing. Check static/sample_asteroid.json.', true);
        }
      }
    }

    function renderNeo(neo) {
      state.currentNeo = neo;
      const name = neo.name || 'Unknown NEO';
      const idLabel = neo.id ? ` (${neo.id})` : '';
      const factsEl = document.getElementById('neo-facts');
      const statusEl = document.getElementById('neo-status');
      const input = document.getElementById('neo-id-input');

      if (input && neo.id) {
        input.value = neo.id;
      }

      document.getElementById('neo-name').textContent = `${name}${idLabel}`;
  updateApproachMetric(neo);

      const facts = [];
      if (neo.estimated_diameter_min_m && neo.estimated_diameter_max_m) {
        facts.push(`<li>Diameter: ${formatNumber(neo.estimated_diameter_min_m)}–${formatNumber(neo.estimated_diameter_max_m)} m</li>`);
      } else if (neo.estimated_diameter_m) {
        facts.push(`<li>Diameter: ${formatNumber(neo.estimated_diameter_m)} m</li>`);
      }
      if (neo.velocity_kms) {
        facts.push(`<li>Velocity: ${formatNumber(neo.velocity_kms, { maximumFractionDigits: 2 })} km/s</li>`);
      }
      if (neo.miss_distance_km) {
        facts.push(`<li>Miss Distance: ${formatNumber(neo.miss_distance_km / 1000, { maximumFractionDigits: 2 })} Mm</li>`);
      }
      if (neo.close_approach_date) {
        facts.push(`<li>Close Approach: ${neo.close_approach_date}</li>`);
      }
      if (typeof neo.potentially_hazardous === 'boolean') {
        facts.push(`<li>Potentially Hazardous: ${neo.potentially_hazardous ? 'Yes' : 'No'}</li>`);
      }
      if (neo.absolute_magnitude_h !== undefined) {
        facts.push(`<li>Abs Magnitude (H): ${formatNumber(neo.absolute_magnitude_h, { maximumFractionDigits: 2 })}</li>`);
      }

      factsEl.innerHTML = facts.length ? facts.join('') : '<li>Awaiting additional data…</li>';

      const sourceLabel = neo.source === 'nasa' ? 'Live data from NASA NeoWs.' : 'Hackathon mock dataset in use.';
      const message = neo.message ? `${neo.message}` : sourceLabel;
      if (statusEl) {
        const resolvedNote = neo.resolved_id && neo.resolved_id !== neo.requested_id
          ? ` Resolved via SPK-ID ${neo.resolved_id}.`
          : '';
        statusEl.textContent = `${message}${resolvedNote}`.trim();
      }

      updateOrbitFromNeo(neo);
      updateMapFromNeo(neo);
      updateMissionPlannerFromNeo(neo);
    }

    function setNeoStatus(message) {
      const statusEl = document.getElementById('neo-status');
      if (statusEl) {
        statusEl.textContent = message;
      }
    }

    function formatNumber(value, options = {}) {
      if (value === null || value === undefined || value === '') {
        return '—';
      }
      const number = Number(value);
      if (Number.isNaN(number)) {
        return '—';
      }
      const { maximumFractionDigits = 1, minimumFractionDigits = 0 } = options;
      return number.toLocaleString(undefined, { maximumFractionDigits, minimumFractionDigits });
    }

    function syncSlidersFromNeo(neo) {
      if (!neo) return;
      if (neo.estimated_diameter_m || neo.estimated_diameter_max_m) {
        const diameter = Math.round(neo.estimated_diameter_m || neo.estimated_diameter_max_m);
        setSliderValue('diameter', clamp(diameter, 10, 2000));
      }
      if (neo.velocity_kms) {
        setSliderValue('velocity', clamp(Number(neo.velocity_kms), 11, 75).toFixed(1));
      }
      if (neo.density_kgm3) {
        setSliderValue('density', clamp(Math.round(neo.density_kgm3), 500, 8000));
      }
      simulate();
      updateMissionPlannerFromNeo(neo);
    }

    function setSliderValue(id, value) {
      const config = sliderConfig.find(cfg => cfg.id === id);
      const slider = document.getElementById(id);
      if (!config || !slider) return;
      let numericValue = value;
      if (typeof value === 'string') {
        numericValue = Number(value);
      }
      if (Number.isFinite(numericValue)) {
        slider.value = numericValue;
      }
      const displayEl = document.getElementById(config.valueId);
      const numericDisplay = Number(slider.value);
      if (Number.isFinite(numericDisplay)) {
        displayEl.textContent = id === 'velocity' ? numericDisplay.toFixed(1) : Math.round(numericDisplay);
      } else {
        displayEl.textContent = slider.value;
      }
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, Number(value)));
    }

    async function handleRunImpact(event) {
      if (event && typeof event.preventDefault === 'function') {
        event.preventDefault();
      }
      const button = event?.currentTarget;
      const originalLabel = button?.textContent || 'Run Impact Simulation';
      if (button) {
        button.disabled = true;
        button.textContent = 'Running…';
      }
      try {
        const result = await simulate();
        if (result) {
          const controlSection = document.getElementById('control');
          if (controlSection) {
            controlSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
          showToast('Impact simulation updated.');
        }
      } finally {
        if (button) {
          button.disabled = false;
          button.textContent = originalLabel;
        }
      }
    }

    async function simulate() {
      const payload = {
        diameter: Number(document.getElementById('diameter').value),
        velocity: Number(document.getElementById('velocity').value),
        density: Number(document.getElementById('density').value),
        delta_v: Number(document.getElementById('delta-v').value)
      };
      try {
        const res = await fetch(`${API_BASE}/simulate-impact`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await res.json();
        updateStats(data);
        const report = updateSeverity(data);
        updateChart(data);
        updateTimeline(data);
        refreshLeaderboard(report.readiness);
        applyDeltaVToOrbit(payload.delta_v);
        updateCraterOnMap(data.crater_diameter_m);
        return data;
      } catch (error) {
        showToast('Simulation API unreachable. Ensure Flask backend is running.', true);
        return null;
      }
    }

    function updateStats(data) {
      document.getElementById('metric-ke').textContent = Number(data.kinetic_energy_j).toExponential(3);
      document.getElementById('metric-tnt').textContent = Math.round(data.tnt_equivalent_tons).toLocaleString();
      document.getElementById('metric-crater').textContent = data.crater_diameter_m.toFixed(1);
      document.getElementById('metric-seismic').textContent = data.seismic_magnitude_mw.toFixed(2);
    }

    function updateSeverity(data) {
      const megatons = data.tnt_equivalent_tons / 1e6;
      const level = severityLevels.find(l => megatons < l.threshold) || severityLevels[severityLevels.length - 1];
      const ratio = Math.min(1, megatons / severityLevels[severityLevels.length - 1].threshold);
      document.getElementById('severity-label').textContent = level.label;
      document.getElementById('severity-tagline').textContent = level.tagline;
      document.getElementById('severity-fill').style.background = `linear-gradient(90deg, ${level.color}, #1b2735)`;
      document.getElementById('severity-fill').style.width = `${Math.max(10, ratio * 100)}%`;
      document.getElementById('severity-detail').textContent = `${megatons.toFixed(2)} megatons TNT — compare to the 1883 Krakatoa eruption (~200 MT).`;
      document.getElementById('confidence-meter').style.width = `${Math.min(100, 20 + (ratio * 80))}%`;
      const readiness = Math.max(62, 100 - (ratio * 55) - (Number(document.getElementById('delta-v').value) * 1.5));
      document.getElementById('confidence-copy').textContent = readiness > 80 ? 'Mission posture strong — keep iterating optimizations.' : 'High-stakes scenario — coordinate international assets.';
      state.lastReadiness = readiness;
      return { megatons, ratio, level, readiness };
    }

    function updateTimeline(data) {
      const megatons = data.tnt_equivalent_tons / 1e6;
      const deltaV = Number(document.getElementById('delta-v').value);
      const leadDays = Number(document.getElementById('lead-time').value);
      const leadHours = Math.max(6, Math.round(leadDays * 24));
      const timeline = document.getElementById('response-timeline');
      const steps = [
        `T-48h: Finalize global messaging. ${megatons < 5 ? 'Regional' : 'Planetary'} response on standby.`,
        `T-${leadHours}h: Execute ${deltaV > 0 ? 'deflection burn' : 'coordinated evacuation drills'} and deploy sensor grid.`,
        `T-6h: Redirect observation assets to confirm trajectory shift.`,
        megatons > 100 ? 'T-1h: Initiate global shelter protocols and emergency broadcasting.' : 'T-1h: Activate local emergency services and hospitals.'
      ];
      timeline.innerHTML = steps.map(step => `<li>${step}</li>`).join('');
    }

    function updateChart(data) {
      const ctx = document.getElementById('impact-chart').getContext('2d');
      if (!state.chart) {
        state.chart = new Chart(ctx, {
          type: 'radar',
          data: {
            labels: ['Kinetic Energy', 'Crater Size', 'Seismic Shock', 'Deflection Opportunity', 'Population Risk'],
            datasets: [{
              label: 'Scenario Severity',
              data: [0, 0, 0, 0, 0],
              backgroundColor: 'rgba(255, 109, 132, 0.3)',
              borderColor: '#ff6d84'
            }]
          },
          options: {
            scales: {
              r: {
                suggestedMin: 0,
                suggestedMax: 100,
                grid: { color: 'rgba(255,255,255,0.1)' },
                angleLines: { color: 'rgba(255,255,255,0.15)' },
                pointLabels: { color: '#fff', font: { family: 'Inter' } }
              }
            },
            plugins: {
              legend: { display: false }
            }
          }
        });
      }
      const megatons = data.tnt_equivalent_tons / 1e6;
      const severityScore = Math.min(100, megatons * 5);
      const craterScore = Math.min(100, data.crater_diameter_m / 20);
      const seismicScore = Math.min(100, (data.seismic_magnitude_mw / 10) * 100);
      const deflectionScore = 100 - Math.min(100, Number(document.getElementById('delta-v').value) * 6);
      const populationRisk = state.impactLat === null ? 40 : Math.min(100, Math.abs(state.impactLat) < 30 ? 90 : 60);
      state.chart.data.datasets[0].data = [severityScore, craterScore, seismicScore, deflectionScore, populationRisk];
      state.chart.update();
    }

    function updateCraterOnMap(craterDiam) {
      if (state.impactLat === null || state.impactLng === null) return;
      if (state.craterCircle) {
        state.map.removeLayer(state.craterCircle);
      }
      const radius = (craterDiam || 1000) / 2;
      state.craterCircle = L.circle([state.impactLat, state.impactLng], {
        radius,
        color: '#ffd166',
        fillColor: '#ffd166',
        fillOpacity: 0.25
      }).addTo(state.map);
    }

    function refreshOrbitGeometry() {
      const params = state.orbitParams || state.baseOrbitParams;
      const semiMajor = Math.max(0.25, Number(params?.semiMajor) || 3);
      const semiMinor = Math.max(0.25, Number(params?.semiMinor) || 1.8);
      const curve = new THREE.EllipseCurve(0, 0, semiMajor, semiMinor, 0, 2 * Math.PI, false, 0);
      const points = curve.getPoints(240).map(p => new THREE.Vector3(p.x, 0, p.y));
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      if (state.orbit.geometry) {
        state.orbit.geometry.dispose();
      }
      state.orbit.geometry = geometry;
      state.orbit.computeLineDistances();
    }

    function applyDeltaVToOrbit(deltaV = 0) {
      if (!state.orbit) return;
      const base = state.baseOrbitParams || state.orbitParams;
      if (!base) return;
      const dv = Math.max(0, Number(deltaV) || 0);
      const stretch = 1 + Math.min(0.6, dv * 0.04);
      const flatten = Math.max(0.55, 1 - dv * 0.035);
      state.orbitParams = {
        semiMajor: base.semiMajor * stretch,
        semiMinor: base.semiMinor * stretch * flatten,
        inclination: base.inclination + dv * 0.8,
        ascendingNode: base.ascendingNode,
        periodDays: base.periodDays * (1 + Math.min(0.6, dv * 0.05))
      };
      refreshOrbitGeometry();
      if (state.orbitGroup) {
        state.orbitGroup.rotation.set(
          THREE.MathUtils.degToRad(state.orbitParams.inclination || 0),
          THREE.MathUtils.degToRad(state.orbitParams.ascendingNode || 0),
          0
        );
      }
      if (state.orbit.material) {
        state.orbit.material.color.set(dv >= 1.5 ? 0x3ddab4 : 0xffd166);
        state.orbit.material.dashSize = dv >= 1.5 ? 0.12 : 0.2;
        state.orbit.material.gapSize = dv >= 1.5 ? 0.08 : 0.05;
        state.orbit.material.needsUpdate = true;
      }
      if (state.asteroidMesh) {
        state.asteroidMesh.material.color.set(dv >= 1.5 ? 0x3ddab4 : 0xff6d84);
      }
      renderOrbitOverlay(state.currentNeo);
    }

    function updateOrbitDeltaDisplay(deltaV) {
      const el = document.getElementById('orbit-delta');
      if (el) {
        el.textContent = `${Number(deltaV).toFixed(1)} km/s`;
      }
    }

    function renderOrbitOverlay(neo) {
      const sourceEl = document.getElementById('orbit-source');
      const live = neo?.source === 'nasa';
      if (sourceEl) {
        sourceEl.textContent = live ? 'NASA LIVE' : 'Mock Orbit';
        sourceEl.classList.toggle('nasa', live);
      }
      const orbitParams = state.orbitParams || state.baseOrbitParams;
      const periodDays = orbitParams?.periodDays;
      let eccentricity = Number(neo?.orbit?.eccentricity);
      if (!Number.isFinite(eccentricity) && orbitParams?.semiMajor && orbitParams?.semiMinor) {
        eccentricity = Math.sqrt(Math.max(0, 1 - Math.pow(orbitParams.semiMinor / orbitParams.semiMajor, 2)));
      }
      const inclination = orbitParams?.inclination;
      setOrbitMetric('orbit-period', periodDays ? `${Math.round(periodDays)} d` : '—');
      setOrbitMetric('orbit-eccentricity', Number.isFinite(eccentricity) ? eccentricity.toFixed(3) : '—');
      setOrbitMetric('orbit-inclination', Number.isFinite(inclination) ? `${inclination.toFixed(2)}°` : '—');
      updateOrbitDeltaDisplay(Number(document.getElementById('delta-v').value || 0));
    }

    function setOrbitMetric(id, value) {
      const el = document.getElementById(id);
      if (el) {
        el.textContent = value;
      }
    }

    function updateOrbitFromNeo(neo) {
      if (!state.orbit) return;
      const orbit = neo?.orbit || {};
      const semiMajorAU = Number(orbit.semi_major_axis_au);
      const eccentricity = clamp(Number(orbit.eccentricity) || 0, 0, 0.98);
      const baseScale = 3;
      const semiMajor = Number.isFinite(semiMajorAU) ? baseScale * semiMajorAU : state.baseOrbitParams.semiMajor;
      const semiMinor = semiMajor * Math.sqrt(Math.max(0.04, 1 - Math.pow(eccentricity, 2)));
      let period = Number(orbit.orbital_period_days || orbit.orbital_period);
      if (!Number.isFinite(period) && Number.isFinite(semiMajorAU)) {
        period = Math.pow(semiMajorAU, 1.5) * 365.25;
      }
      const inclination = Number(orbit.inclination_deg) || 0;
      const ascending = Number(orbit.ascending_node_longitude_deg) || 0;

      state.baseOrbitParams = {
        semiMajor,
        semiMinor,
        inclination,
        ascendingNode: ascending,
        periodDays: Math.max(1, period || state.baseOrbitParams.periodDays)
      };
      state.orbitParams = { ...state.baseOrbitParams };
      refreshOrbitGeometry();
      if (state.orbitGroup) {
        state.orbitGroup.rotation.set(
          THREE.MathUtils.degToRad(state.orbitParams.inclination || 0),
          THREE.MathUtils.degToRad(state.orbitParams.ascendingNode || 0),
          0
        );
      }
      renderOrbitOverlay(neo);
      applyDeltaVToOrbit(Number(document.getElementById('delta-v').value || 0));
    }

    function updateMapFromNeo(neo) {
      if (!neo || !state.map) return;
      if (state.impactLat === null || state.impactLng === null) {
        const inclination = Number((neo.orbit || {}).inclination_deg) || 0;
        const ascNode = Number((neo.orbit || {}).ascending_node_longitude_deg) || 0;
        state.impactLat = Math.max(-60, Math.min(60, inclination / 2 || 12));
        state.impactLng = ((ascNode % 360) + 540) % 360 - 180;
        state.map.setView([state.impactLat, state.impactLng], 3);
        document.getElementById('impact-location').textContent = `${state.impactLat.toFixed(2)}, ${state.impactLng.toFixed(2)} (auto)`;
      }
      const crater = Number(neo.estimated_diameter_max_m || neo.estimated_diameter_m);
      if (Number.isFinite(crater)) {
        updateCraterOnMap(crater);
      }
    }

    function updateMissionPlannerFromNeo(neo) {
      if (!neo) return;
      const leadInput = document.getElementById('lead-time');
      const budgetInput = document.getElementById('mission-budget');
      const closeApproach = parseNeoDate(neo.close_approach_date);
      if (leadInput && closeApproach) {
        const diffDays = Math.max(1, Math.round((closeApproach.getTime() - Date.now()) / (1000 * 60 * 60 * 24)));
        leadInput.value = diffDays;
      }
      const diameter = Number(document.getElementById('diameter').value);
      if (budgetInput && Number.isFinite(diameter)) {
        const suggested = Math.min(400, Math.max(15, Math.round(diameter / 8)));
        budgetInput.value = suggested;
      }
      const strategy = document.getElementById('strategy').value;
      const lead = Number(document.getElementById('lead-time').value);
      const budget = Number(document.getElementById('mission-budget').value);
      const deltaV = Number(document.getElementById('delta-v').value);
      const velocity = Number(document.getElementById('velocity').value);
      const brief = buildMissionBrief({ strategy, lead, budget, deltaV, diameter, velocity });
      document.getElementById('mission-brief').innerHTML = brief;
    }

    function parseNeoDate(value) {
      if (!value) return null;
      const isoCandidate = value.replace(' ', 'T');
      let parsed = new Date(isoCandidate);
      if (Number.isNaN(parsed.getTime())) {
        parsed = new Date(`${isoCandidate}Z`);
      }
      if (Number.isNaN(parsed.getTime())) {
        return null;
      }
      return parsed;
    }

    function updateApproachMetric(neo) {
      const countdownEl = document.getElementById('neo-approach-countdown');
      const dateEl = document.getElementById('neo-approach-date');
      if (!countdownEl || !dateEl) return;
  const closeApproach = neo && neo.close_approach_date ? neo.close_approach_date : null;
  const targetDate = parseNeoDate(closeApproach);
      if (!targetDate) {
        countdownEl.textContent = '—';
        dateEl.textContent = 'No upcoming approach data.';
        return;
      }
      const now = new Date();
      const diffMs = targetDate.getTime() - now.getTime();
      const diffDays = Math.floor(Math.abs(diffMs) / (1000 * 60 * 60 * 24));
      const diffHours = Math.floor((Math.abs(diffMs) / (1000 * 60 * 60)) % 24);
      const label = `${diffDays}d ${diffHours.toString().padStart(2, '0')}h`;
      if (diffMs >= 0) {
        countdownEl.textContent = label;
        dateEl.textContent = `Scheduled for ${targetDate.toLocaleString()}`;
      } else {
        countdownEl.textContent = label;
        dateEl.textContent = `Last approach on ${targetDate.toLocaleString()}`;
      }
    }

    function handleOrbitResize() {
      if (!state.orbitRenderer || !state.orbitCamera) return;
      const stage = document.getElementById('orbit-stage');
      if (!stage) return;
      const width = stage.clientWidth || stage.offsetWidth || 620;
      const height = stage.clientHeight || 420;
      state.orbitCamera.aspect = width / height;
      state.orbitCamera.updateProjectionMatrix();
      state.orbitRenderer.setSize(width, height);
      updateCameraFromControls();
    }

    function updateCameraFromControls() {
      if (!state.orbitCamera || !state.orbitControlState) return;
      const { azimuth, polar, distance } = state.orbitControlState;
      const radius = Math.max(2.5, Math.min(16, distance));
      const polarClamped = Math.max(0.2, Math.min(Math.PI - 0.2, polar));
      const x = radius * Math.sin(polarClamped) * Math.sin(azimuth);
      const y = radius * Math.cos(polarClamped);
      const z = radius * Math.sin(polarClamped) * Math.cos(azimuth);
      state.orbitCamera.position.set(x, y, z);
      state.orbitCamera.lookAt(0, 0, 0);
    }

  function setupOrbitInteractions(canvas) {
      const controls = state.orbitControlState;
      const pointer = { active: false, id: null, lastX: 0, lastY: 0 };
      if (!canvas) return;
      canvas.style.touchAction = 'none';

      const onPointerDown = (event) => {
        pointer.active = true;
        pointer.id = event.pointerId;
        pointer.lastX = event.clientX;
        pointer.lastY = event.clientY;
        canvas.setPointerCapture(event.pointerId);
      };

      const onPointerMove = (event) => {
        if (!pointer.active || pointer.id !== event.pointerId) return;
        const deltaX = event.clientX - pointer.lastX;
        const deltaY = event.clientY - pointer.lastY;
        pointer.lastX = event.clientX;
        pointer.lastY = event.clientY;
        controls.azimuth -= deltaX * 0.005;
        controls.polar -= deltaY * 0.0035;
        updateCameraFromControls();
      };

      const stopInteraction = (event) => {
        if (pointer.active && pointer.id === event.pointerId) {
          canvas.releasePointerCapture(event.pointerId);
          pointer.active = false;
          pointer.id = null;
        }
      };

      const onWheel = (event) => {
        event.preventDefault();
        const zoomDelta = event.deltaY * 0.0045;
        controls.distance += zoomDelta;
        controls.distance = Math.max(1.8, Math.min(14, controls.distance));
        updateCameraFromControls();
      };

      canvas.addEventListener('pointerdown', onPointerDown);
      canvas.addEventListener('pointermove', onPointerMove);
      canvas.addEventListener('pointerup', stopInteraction);
      canvas.addEventListener('pointerleave', stopInteraction);
      canvas.addEventListener('pointercancel', stopInteraction);
      canvas.addEventListener('wheel', onWheel, { passive: false });

      state.orbitControls = {
        dispose() {
          canvas.removeEventListener('pointerdown', onPointerDown);
          canvas.removeEventListener('pointermove', onPointerMove);
          canvas.removeEventListener('pointerup', stopInteraction);
          canvas.removeEventListener('pointerleave', stopInteraction);
          canvas.removeEventListener('pointercancel', stopInteraction);
          canvas.removeEventListener('wheel', onWheel);
        }
      };
    }

    function buildStarfield(scene) {
      const starGeometry = new THREE.BufferGeometry();
      const starCount = 950;
      const positions = new Float32Array(starCount * 3);
      const colors = new Float32Array(starCount * 3);
      const color = new THREE.Color();
      for (let i = 0; i < starCount; i += 1) {
        const radius = 22 + Math.random() * 24;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i * 3 + 1] = radius * Math.cos(phi) * 0.45;
        positions[i * 3 + 2] = radius * Math.sin(phi) * Math.sin(theta);
        const hue = 0.55 + Math.random() * 0.1;
        const lightness = 0.7 + Math.random() * 0.28;
        color.setHSL(hue, 0.25 + Math.random() * 0.25, Math.min(1, lightness));
        colors[i * 3] = color.r;
        colors[i * 3 + 1] = color.g;
        colors[i * 3 + 2] = color.b;
      }
      starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      const starMaterial = new THREE.PointsMaterial({
        size: 0.12,
        vertexColors: true,
        transparent: true,
        opacity: 1,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
      });
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
    }

    function buildMissionBrief({ strategy, lead, budget, deltaV, diameter, velocity }) {
      const strategyCopy = {
        kinetic: 'Kinetic impactor mission with autonomous targeting and twin impactors for redundancy.',
        gravity: 'Long-duration gravity tractor to nudge velocity through sustained pull.',
        nuclear: 'Standoff nuclear detonation to ablate the surface and impart momentum.',
        laser: 'Solar-pumped laser array delivering gradual momentum change.'
      };
      const recommendedDeltaV = Math.max(0.1, (diameter / 300) * (velocity / 25) / (lead / 90));
      const budgetSignal = budget > 100 ? 'large-scale' : budget > 40 ? 'robust' : 'lean yet focused';
      return `
        <p><strong>Strategy:</strong> ${strategyCopy[strategy]}</p>
        <p><strong>Recommended Δv:</strong> ${recommendedDeltaV.toFixed(2)} km/s (current plan: ${deltaV.toFixed(2)} km/s)</p>
        <p><strong>Lead Time:</strong> ${lead} days — keep cadence with mission rehearsal campaigns.</p>
        <p><strong>Budget Outlook:</strong> ${budgetSignal} allocation primed for international co-funding.</p>
        <p><strong>Action Items:</strong> sync navigation team, confirm launch window, and broadcast BRR (Blue Ribbon Review) briefing.</p>
      `;
    }

    function defendEarth() {
      const deltaV = Number(document.getElementById('delta-v').value);
      if (!state.orbit) return;
      const success = deltaV >= 1.5;
      state.orbit.material.color.set(success ? 0x3ddab4 : 0xff6d84);
      document.getElementById('defend-result').textContent = success ? 'Deflection nominal! Orbital solution indicates safe miss distance.' : 'Δv insufficient. Iterate mission plan and escalate countermeasures.';
      showToast(success ? 'Orbit diverted — Earth is safe (for now)!' : 'Need more thrust. Boost Δv or swap tactics.');
    }

    function saveScenario() {
      const location = state.impactLat === null ? 'Unassigned' : `${state.impactLat.toFixed(2)}, ${state.impactLng.toFixed(2)}`;
      const scenario = {
        timestamp: new Date().toLocaleTimeString(),
        diameter: document.getElementById('diameter').value,
        velocity: document.getElementById('velocity').value,
        severity: document.getElementById('severity-label').textContent,
        readiness: state.lastReadiness.toFixed(1),
        location
      };
      if (state.scenarios.length >= 5) {
        state.scenarios.shift();
      }
      state.scenarios.push(scenario);
      renderScenarioVault();
      refreshLeaderboard(state.lastReadiness + 0.4);
      showToast('Scenario saved to vault. Leaderboard recalibrated.');
    }

    function renderScenarioVault() {
      const list = document.getElementById('scenario-list');
      if (!state.scenarios.length) {
        list.innerHTML = '<li>No scenarios saved yet.</li>';
        return;
      }
      list.innerHTML = state.scenarios.map(s => `
        <li>
          <strong>${s.severity}</strong> • ${s.diameter} m @ ${s.velocity} km/s
          <span class="timestamp">${s.location} • readiness ${s.readiness}% • saved ${s.timestamp}</span>
        </li>
      `).join('');
    }

    function refreshLeaderboard(readinessScore) {
      if (Number.isFinite(readinessScore)) {
        state.lastReadiness = readinessScore;
      }
      const board = document.getElementById('leaderboard');
      const top = board.querySelector('li');
      if (top) {
        top.innerHTML = `<strong>Team Syntax</strong> — ${state.lastReadiness.toFixed(1)}% mission readiness`;
      }
    }

    function addMissionNote() {
      const promptText = prompt('Add a mission control note for teammates:');
      if (!promptText) return;
      const notes = document.getElementById('mission-notes');
      const li = document.createElement('li');
      li.textContent = promptText;
      notes.appendChild(li);
      showToast('Mission note added.');
    }

    function showToast(message, danger = false) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.toggle('danger', danger);
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 3200);
    }

    function downloadMissionBrief() {
      try {
        const now = new Date();
        const header = `Mission Brief — ${now.toLocaleString()}`;
        const lines = [header, ''.padStart(header.length, '='), ''];

        const neo = state.currentNeo;
        lines.push('NEO Target:');
        if (neo) {
          lines.push(
            `- Name: ${neo.name || 'Unknown NEO'}`,
            `- Requested ID: ${neo.requested_id || neo.id || '—'}`,
            `- Resolved ID: ${neo.resolved_id || neo.id || '—'}`,
            `- Close Approach: ${neo.close_approach_date || '—'}`,
            `- Velocity: ${neo.velocity_kms !== undefined ? `${neo.velocity_kms} km/s` : '—'}`,
            `- Miss Distance: ${neo.miss_distance_km ? `${neo.miss_distance_km.toLocaleString()} km` : '—'}`,
            `- Potentially Hazardous: ${typeof neo.potentially_hazardous === 'boolean' ? (neo.potentially_hazardous ? 'Yes' : 'No') : '—'}`
          );
        } else {
          lines.push('- Awaiting NASA NeoWs data. Fetch a NEO to include live intel.');
        }

        lines.push('', 'Impact Parameters:');
        const diameterInput = document.getElementById('diameter');
        const velocityInput = document.getElementById('velocity');
        const densityInput = document.getElementById('density');
        const deltaVInput = document.getElementById('delta-v');
        lines.push(
          `- Diameter: ${diameterInput ? `${diameterInput.value} m` : '—'}`,
          `- Velocity: ${velocityInput ? `${velocityInput.value} km/s` : '—'}`,
          `- Density: ${densityInput ? `${densityInput.value} kg/m³` : '—'}`,
          `- Deflection Δv: ${deltaVInput ? `${deltaVInput.value} km/s` : '—'}`
        );

        lines.push('', 'Simulation Metrics:');
        const metricPairs = [
          ['Kinetic Energy', document.getElementById('metric-ke')?.textContent?.trim()],
          ['TNT Equivalent', document.getElementById('metric-tnt')?.textContent?.trim()],
          ['Crater Diameter', document.getElementById('metric-crater')?.textContent?.trim()],
          ['Seismic Magnitude', document.getElementById('metric-seismic')?.textContent?.trim()]
        ];
        metricPairs.forEach(([label, value]) => {
          lines.push(`- ${label}: ${value || '—'}`);
        });

        lines.push('', 'Severity & Readiness:');
        const severityLabel = document.getElementById('severity-label')?.textContent?.trim() || '—';
        const severityTagline = document.getElementById('severity-tagline')?.textContent?.trim();
        const severityDetail = document.getElementById('severity-detail')?.textContent?.trim();
        lines.push(`- Severity Level: ${severityLabel}`);
        if (severityTagline) {
          lines.push(`- Tagline: ${severityTagline}`);
        }
        if (severityDetail) {
          lines.push(`- Detail: ${severityDetail}`);
        }
        lines.push(`- Mission Readiness: ${Number.isFinite(state.lastReadiness) ? `${state.lastReadiness.toFixed(1)}%` : '—'}`);

        const missionBriefEl = document.getElementById('mission-brief');
        const briefText = missionBriefEl?.innerText?.trim();
        if (briefText) {
          lines.push('', 'Mission Brief Narrative:', briefText);
        }

        const timelineItems = Array.from(document.querySelectorAll('#response-timeline li'))
          .map(item => item.textContent.trim())
          .filter(Boolean);
        lines.push('', 'Response Timeline:');
        if (timelineItems.length) {
          timelineItems.forEach(item => lines.push(`- ${item}`));
        } else {
          lines.push('- Awaiting simulation results.');
        }

        const noteItems = Array.from(document.querySelectorAll('#mission-notes li'))
          .map(item => item.textContent.trim())
          .filter(Boolean);
        lines.push('', 'Mission Control Notes:');
        if (noteItems.length) {
          noteItems.forEach(note => lines.push(`- ${note}`));
        } else {
          lines.push('- No notes recorded.');
        }

        lines.push('', 'Scenario Vault Snapshot:');
        if (Array.isArray(state.scenarios) && state.scenarios.length) {
          state.scenarios.forEach(scenario => {
            lines.push(`- ${scenario.timestamp}: ${scenario.severity} • ${scenario.diameter} m @ ${scenario.velocity} km/s • readiness ${scenario.readiness}% (${scenario.location})`);
          });
        } else {
          lines.push('- No scenarios saved yet.');
        }

        lines.push('', 'Generated via Meteor Madness Mission Control — NASA Space Apps 2025');

        const blob = new Blob([lines.join('\n')], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const anchor = document.createElement('a');
        anchor.href = url;
        anchor.download = `mission-brief-${now.toISOString().replace(/[:.]/g, '-')}.txt`;
        document.body.appendChild(anchor);
        anchor.click();
        document.body.removeChild(anchor);
        URL.revokeObjectURL(url);
        showToast('Mission brief downloaded to your device.');
      } catch (error) {
        console.error('Mission brief download failed:', error);
        showToast('Unable to download mission brief. Try again after running a simulation.', true);
      }
    }

    function initMap() {
      state.map = L.map('impact-map', {
        worldCopyJump: true,
        minZoom: 2,
        maxZoom: 8
      }).setView([20, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '© OpenStreetMap contributors'
      }).addTo(state.map);
      const cities = [
        { name: 'New York', coords: [40.7128, -74.0060] },
        { name: 'Tokyo', coords: [35.6762, 139.6503] },
        { name: 'Nairobi', coords: [-1.2921, 36.8219] },
        { name: 'Brasília', coords: [-15.8267, -47.9218] }
      ];
      cities.forEach(city => {
        L.circleMarker(city.coords, { radius: 4, color: '#06d6a0', fillColor: '#06d6a0', fillOpacity: 0.8 })
          .addTo(state.map)
          .bindPopup(city.name);
      });
      state.map.on('click', (event) => {
        state.impactLat = event.latlng.lat;
        state.impactLng = event.latlng.lng;
        document.getElementById('impact-location').textContent = `${state.impactLat.toFixed(2)}, ${state.impactLng.toFixed(2)}`;
        simulate();
      });
    }

    function initOrbit() {
      const stage = document.getElementById('orbit-stage');
      const width = stage.clientWidth || stage.offsetWidth || 620;
      const height = stage.clientHeight || 420;
      if (state.orbitControls && typeof state.orbitControls.dispose === 'function') {
        state.orbitControls.dispose();
        state.orbitControls = null;
      }
      state.moon = null;
      state.moonGroup = null;
      state.moonLight = null;
      state.moonOrbitLine = null;
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 200);
      camera.position.set(0, 3.2, 7.5);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
      renderer.setSize(width, height);
      renderer.setClearColor(0x050b18, 1);
      stage.innerHTML = '';
      stage.appendChild(renderer.domElement);

      const deepBackdrop = new THREE.Mesh(
        new THREE.SphereGeometry(80, 64, 64),
        new THREE.MeshBasicMaterial({ color: 0x020612, side: THREE.BackSide, transparent: true, opacity: 0.92 })
      );
      scene.add(deepBackdrop);

      buildStarfield(scene);

      const ambient = new THREE.AmbientLight(0x142338, 0.55);
      scene.add(ambient);
      const rimLight = new THREE.PointLight(0x6dcff6, 0.65, 90);
      rimLight.position.set(7, -4, 9);
      scene.add(rimLight);

      const sunGroup = new THREE.Group();
      sunGroup.position.set(-14, 3.5, -20);
      const sunCore = new THREE.Mesh(
        new THREE.SphereGeometry(3.2, 48, 48),
        new THREE.MeshStandardMaterial({ color: 0xfff2a8, emissive: 0xffd166, emissiveIntensity: 1.4, roughness: 0.18, metalness: 0.1 })
      );
      sunGroup.add(sunCore);
      const sunCorona = new THREE.Mesh(
        new THREE.RingGeometry(3.6, 5.6, 96),
        new THREE.MeshBasicMaterial({ color: 0xfff9d5, transparent: true, opacity: 0.32, side: THREE.DoubleSide })
      );
      sunCorona.rotation.x = Math.PI / 2;
      sunGroup.add(sunCorona);
      const sunFlare = new THREE.Mesh(
        new THREE.RingGeometry(5.8, 7.8, 120),
        new THREE.MeshBasicMaterial({ color: 0xffc15f, transparent: true, opacity: 0.16, side: THREE.DoubleSide })
      );
      sunFlare.rotation.x = Math.PI / 2;
      sunGroup.add(sunFlare);
      scene.add(sunGroup);

      const sunLight = new THREE.DirectionalLight(0xfff3c4, 1.25);
      sunLight.position.copy(sunGroup.position);
      sunLight.target.position.set(0, 0, 0);
      scene.add(sunLight);
      scene.add(sunLight.target);
      const fillLight = new THREE.PointLight(0xffb387, 0.4, 60);
      fillLight.position.set(-6, 6, -12);
      scene.add(fillLight);

      const earth = new THREE.Mesh(
        new THREE.SphereGeometry(1, 48, 48),
        new THREE.MeshStandardMaterial({ color: 0x2f6bff, emissive: 0x12305f, roughness: 0.35, metalness: 0.15 })
      );
      earth.rotation.z = -23.5 * (Math.PI / 180);
      scene.add(earth);
      const earthGlow = new THREE.Mesh(
        new THREE.RingGeometry(1.05, 1.35, 96),
        new THREE.MeshBasicMaterial({ color: 0x4fb7ff, transparent: true, opacity: 0.16, side: THREE.DoubleSide })
      );
      earthGlow.rotation.x = Math.PI / 2;
      scene.add(earthGlow);

      const moonOrbitRadius = state.moonOrbitRadius || 6;
      const moonGroup = new THREE.Group();
      moonGroup.position.set(0, 0, 0);
      const moon = new THREE.Mesh(
        new THREE.SphereGeometry(0.27, 32, 32),
        new THREE.MeshStandardMaterial({ color: 0xdedcd4, emissive: 0x2b2a28, emissiveIntensity: 0.25, roughness: 0.8, metalness: 0.05 })
      );
      moon.position.set(moonOrbitRadius, 0, 0);
      moonGroup.add(moon);
      const moonOrbitCurve = new THREE.EllipseCurve(0, 0, moonOrbitRadius, moonOrbitRadius);
      const moonOrbitPoints = moonOrbitCurve.getPoints(256).map(point => new THREE.Vector3(point.x, 0, point.y));
      const moonOrbitGeometry = new THREE.BufferGeometry().setFromPoints(moonOrbitPoints);
      const moonOrbitMaterial = new THREE.LineBasicMaterial({ color: 0x9ec5ff, transparent: true, opacity: 0.45 });
      const moonOrbitLine = new THREE.LineLoop(moonOrbitGeometry, moonOrbitMaterial);
      moonGroup.add(moonOrbitLine);
      const moonInclination = 5.145 * (Math.PI / 180);
      moonGroup.rotation.x = moonInclination;
      const moonLight = new THREE.PointLight(0x9bb7ff, 0.4, 14);
      moonLight.position.copy(moon.position);
      moonGroup.add(moonLight);
      scene.add(moonGroup);

      const orbitMaterial = new THREE.LineDashedMaterial({ color: 0xffd166, dashSize: 0.2, gapSize: 0.05 });
      const orbit = new THREE.Line(new THREE.BufferGeometry(), orbitMaterial);

      const asteroid = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.15, 2),
        new THREE.MeshStandardMaterial({ color: 0xff6d84, emissive: 0x441424, roughness: 0.45, metalness: 0.35 })
      );
      asteroid.position.set(state.orbitParams.semiMajor, 0, 0);

      const trailSegments = 160;
      const trailPositions = new Float32Array(trailSegments * 3);
      const trailGeometry = new THREE.BufferGeometry();
      trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
      const trailMaterial = new THREE.LineBasicMaterial({ color: 0xff6d84, transparent: true, opacity: 0.55 });
      const trail = new THREE.Line(trailGeometry, trailMaterial);

      const orbitGroup = new THREE.Group();
      orbitGroup.add(orbit);
      orbitGroup.add(asteroid);
      orbitGroup.add(trail);
      scene.add(orbitGroup);

      camera.lookAt(orbitGroup.position);

      state.orbitScene = scene;
      state.orbitCamera = camera;
      state.orbitRenderer = renderer;
      state.orbit = orbit;
      state.asteroidMesh = asteroid;
      state.orbitGroup = orbitGroup;
      state.orbitTrail = { line: trail, positions: trailPositions };
      state.moon = moon;
      state.moonGroup = moonGroup;
      state.moonLight = moonLight;
      state.moonOrbitLine = moonOrbitLine;
      state.baseOrbitParams = { ...state.orbitParams };

      setupOrbitInteractions(renderer.domElement);
      updateCameraFromControls();

      refreshOrbitGeometry();
      renderOrbitOverlay(state.currentNeo);
      applyDeltaVToOrbit(Number(document.getElementById('delta-v').value || 0));
      handleOrbitResize();

      function animate() {
        requestAnimationFrame(animate);
        const now = Date.now();
        const params = state.orbitParams || state.baseOrbitParams;
        const periodMs = Math.max(1, params.periodDays) * 24 * 60 * 60 * 1000;
        const angle = ((now % periodMs) / periodMs) * (Math.PI * 2);
        const x = params.semiMajor * Math.cos(angle);
        const z = params.semiMinor * Math.sin(angle);
        state.asteroidMesh.position.set(x, 0, z);
        state.asteroidMesh.rotation.y += 0.01;
        if (state.orbitTrail) {
          const positions = state.orbitTrail.positions;
          for (let i = positions.length - 3; i >= 3; i -= 3) {
            positions[i] = positions[i - 3];
            positions[i + 1] = positions[i - 2];
            positions[i + 2] = positions[i - 1];
          }
          positions[0] = x;
          positions[1] = 0;
          positions[2] = z;
          state.orbitTrail.line.geometry.attributes.position.needsUpdate = true;
        }
        if (state.moonGroup && state.moon) {
          const moonPeriodDays = state.moonOrbitPeriodDays || 27.3;
          const moonPeriodMs = moonPeriodDays * 24 * 60 * 60 * 1000;
          const visualSpeedFactor = 48000; // compress real period so motion is visible (~48s per orbit)
          const moonAngle = (now / (moonPeriodMs / visualSpeedFactor)) % (Math.PI * 2);
          state.moonGroup.rotation.y = moonAngle;
          state.moon.rotation.y += 0.012;
          if (state.moonLight) {
            state.moonLight.position.copy(state.moon.position);
          }
        }
        updateCameraFromControls();
        renderer.render(scene, camera);
      }
    animate();
    }

    function init() {
      initMap();
      initOrbit();
      window.addEventListener('resize', handleOrbitResize);
      loadSampleNeo();
      renderScenarioVault();
      simulate();
    }

    window.addEventListener('load', init);
  </script>
</body>
</html>
